name: Deploy SafetyWallet

on:
  workflow_run:
    workflows: ["CI"]
    branches: [master]
    types: [completed]
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref to verify after Cloudflare Git Integration deploy"
        required: false
        default: "master"

concurrency:
  group: deploy-production
  cancel-in-progress: false

permissions:
  contents: read
  actions: read

jobs:
  resolve-sha:
    name: Resolve Deployment SHA
    if: >-
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      deploy-sha: ${{ steps.sha.outputs.deploy_sha }}
      deploy-ref: ${{ steps.sha.outputs.deploy_ref }}
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
      - name: Select source commit
        id: sha
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            DEPLOY_REF="${{ github.event.workflow_run.head_branch }}"
            DEPLOY_SHA="${{ github.event.workflow_run.head_sha }}"
          else
            DEPLOY_REF="${{ inputs.ref || github.ref_name }}"
            git fetch --force --tags origin
            if git rev-parse --verify "${DEPLOY_REF}^{commit}" >/dev/null 2>&1; then
              DEPLOY_SHA="$(git rev-parse "${DEPLOY_REF}^{commit}")"
            elif git rev-parse --verify "origin/${DEPLOY_REF}^{commit}" >/dev/null 2>&1; then
              DEPLOY_SHA="$(git rev-parse "origin/${DEPLOY_REF}^{commit}")"
            else
              echo "::error::Unable to resolve deploy ref: ${DEPLOY_REF}"
              exit 1
            fi
          fi

          echo "deploy_ref=$DEPLOY_REF" >> "$GITHUB_OUTPUT"
          echo "deploy_sha=$DEPLOY_SHA" >> "$GITHUB_OUTPUT"
          echo "Deploy source ref: $DEPLOY_REF"
          echo "Deploy source SHA: $DEPLOY_SHA"

  path-filter:
    name: Check Deploy-Relevant Paths
    needs: [resolve-sha]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should-deploy: ${{ steps.paths.outputs.should_deploy }}
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          fetch-depth: 2
      - name: Determine changed files
        id: paths
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_deploy=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SHA="${{ needs.resolve-sha.outputs.deploy-sha }}"
          changed_files=$(git diff-tree --no-commit-id --name-only -r "$SHA" || true)

          if echo "$changed_files" | grep -Eq '^(apps/(api-worker|admin-app|worker-app)/|packages/(types|ui)/|\.github/workflows/)'; then
            echo "should_deploy=true" >> "$GITHUB_OUTPUT"
          else
            echo "No deploy-relevant changes detected"
            echo "should_deploy=false" >> "$GITHUB_OUTPUT"
          fi

  wait-for-cloudflare-build:
    name: Wait for Cloudflare Git Integration Deploy
    needs: [resolve-sha, path-filter]
    if: needs.path-filter.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      health-reachable: ${{ steps.health.outputs.reachable }}
    steps:
      - name: Wait until production API responds healthy
        id: health
        run: |
          max_attempts=45
          sleep_seconds=20

          check_health() {
            target_url="$1"
            code=$(curl -sS -o /tmp/health.json -w "%{http_code}" --max-time 10 "$target_url" || true)
            health_status=$(node -e 'const fs=require("fs"); try { const d=JSON.parse(fs.readFileSync("/tmp/health.json","utf8")); process.stdout.write(d && d.data && d.data.status ? String(d.data.status) : ""); } catch { process.stdout.write(""); }')
            if [ "$code" = "200" ] && [ "$health_status" = "healthy" ]; then
              return 0
            fi
            return 1
          }

          for i in $(seq 1 "$max_attempts"); do
            if check_health "https://safetywallet.jclee.me/api/health"; then
              echo "Cloudflare deployment appears available (custom domain API)"
              echo "reachable=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            if check_health "https://safetywallet.jclee.workers.dev/api/health"; then
              echo "Cloudflare deployment appears available (workers.dev API fallback)"
              echo "reachable=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            echo "Waiting for Cloudflare deploy... attempt $i/$max_attempts"
            sleep "$sleep_seconds"
          done
          echo "::warning::Production health endpoint unreachable after $max_attempts attempts ‚Äî CF may be blocking runner IPs"
          echo "reachable=false" >> "$GITHUB_OUTPUT"

  sync-r2-assets:
    name: Sync Static Assets to R2
    needs: [path-filter]
    if: needs.path-filter.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: production
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 22
          cache: npm
      - name: Validate R2 credentials
        env:
          CF_KEY: ${{ secrets.CLOUDFLARE_API_KEY }}
          CF_EMAIL: ${{ secrets.CLOUDFLARE_EMAIL }}
        run: |
          if [ -z "$CF_KEY" ] || [ -z "$CF_EMAIL" ]; then
            echo "::error::CLOUDFLARE_API_KEY and CLOUDFLARE_EMAIL secrets required for R2 sync"
            exit 1
          fi
      - run: npm ci
      - name: Build frontend apps
        run: npx turbo run build --filter=@safetywallet/worker-app --filter=@safetywallet/admin-app
      - name: Upload worker-app to R2
        env:
          CLOUDFLARE_API_KEY: ${{ secrets.CLOUDFLARE_API_KEY }}
          CLOUDFLARE_EMAIL: ${{ secrets.CLOUDFLARE_EMAIL }}
        run: bash scripts/sync-r2.sh apps/worker-app/out safetywallet-static
      - name: Upload admin-app to R2
        env:
          CLOUDFLARE_API_KEY: ${{ secrets.CLOUDFLARE_API_KEY }}
          CLOUDFLARE_EMAIL: ${{ secrets.CLOUDFLARE_EMAIL }}
        run: bash scripts/sync-r2.sh apps/admin-app/out safetywallet-static admin

  verify-production:
    name: Verify Production After Git Integration Deploy
    needs: [resolve-sha, wait-for-cloudflare-build, sync-r2-assets, path-filter]
    if: needs.path-filter.outputs.should-deploy == 'true' && needs.wait-for-cloudflare-build.outputs.health-reachable == 'true'
    uses: ./.github/workflows/deploy-verify.yml
    with:
      environment: production
      ref: ${{ needs.resolve-sha.outputs.deploy-sha }}
    secrets: inherit
  notify:
    name: Slack Deploy Notification
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs:
      [
        resolve-sha,
        path-filter,
        wait-for-cloudflare-build,
        sync-r2-assets,
        verify-production,
      ]
    if: always() && needs.path-filter.outputs.should-deploy == 'true'
    steps:
      - name: Notify Slack
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "Slack webhook not configured. Skipping."
            exit 0
          fi

          deploy_sha="${{ needs.resolve-sha.outputs.deploy-sha }}"
          short_sha=$(echo "$deploy_sha" | cut -c1-7)

          cf_result="${{ needs.wait-for-cloudflare-build.result }}"
          verify_result="${{ needs.verify-production.result }}"
          r2_result="${{ needs.sync-r2-assets.result }}"
          health_reachable="${{ needs.wait-for-cloudflare-build.outputs.health-reachable }}"

          if [ "$cf_result" = "success" ] && [ "$r2_result" = "success" ] && [ "$verify_result" = "success" ]; then
            emoji="üöÄ"
            status="deployed & verified"
            color="good"
          elif [ "$cf_result" = "success" ] && [ "$health_reachable" = "false" ]; then
            emoji="‚ö†Ô∏è"
            status="deployed, verification skipped (API unreachable from runner)"
            color="warning"
          elif [ "$r2_result" != "success" ]; then
            emoji="‚ö†Ô∏è"
            status="deployed, R2 sync ${r2_result}"
            color="warning"
          elif [ "$cf_result" = "success" ]; then
            emoji="‚ö†Ô∏è"
            status="deployed, verification ${verify_result}"
            color="warning"
          else
            emoji="‚ùå"
            status="deploy failed"
            color="danger"
          fi

          run_url="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          payload=$(jq -n \
            --arg color "$color" \
            --arg text "${emoji} *Production ${status}* ‚Äî <${run_url}|safetywallet#${short_sha}>" \
            '{attachments: [{color: $color, blocks: [{type: "section", text: {type: "mrkdwn", text: $text}}]}]}')

          curl -sS --fail-with-body --retry 2 --max-time 10 \
            -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "$payload" || echo "::warning::Slack notification failed"
